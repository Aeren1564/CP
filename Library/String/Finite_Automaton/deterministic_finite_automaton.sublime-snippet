<snippet>
	<content><![CDATA[
template<int sigma>
struct deterministic_finite_automaton{
	using DFA_t = deterministic_finite_automaton<sigma>;
	int initial_state;
	vector<array<int, sigma>> next;
	vector<int> is_accepting_state;
	deterministic_finite_automaton(int n): initial_state(0), next(n), is_accepting_state(n){
		assert(1 <= n);
		for(auto u = 0; u < n; ++ u) next[u].fill(-1);
	}
	deterministic_finite_automaton(int initial_state, const vector<array<int, sigma>> &next, const vector<int> &is_accepting_state): initial_state(initial_state), next(next), is_accepting_state(is_accepting_state){ }
	int size() const{
		return (int)next.size();
	}
	// https://en.wikipedia.org/wiki/DFA_minimization
	// Returns the smallest automaton accepting the same regular language
	DFA_t reduce() const{
		vector<int> color = is_accepting_state;
		while(true){
			vector<array<int, sigma + 1>> temp(size());
			for(auto u = 0; u < size(); ++ u){
				temp[u][0] = color[u];
				for(auto c = 0; c < sigma; ++ c) temp[u][c + 1] = color[next[u][c]];
			}
			auto values = temp;
			sort(values.begin(), values.end());
			values.erase(unique(values.begin(), values.end()), values.end());
			vector<int> next_color(size());
			for(auto u = 0; u < size(); ++ u) next_color[u] = lower_bound(values.begin(), values.end(), temp[u]) - values.begin();
			if(color == next_color) break;
			color = next_color;
		}
		int n = max_element(color.begin(), color.end()) + 1;
		auto res = deterministic_finite_automaton(n);
		res.initial_state = color[initial_state];
		for(auto u = 0; u < size(); ++ u){
			if(~res.next[color[u]][0]) continue;
			for(auto c = 0; c < sigma; ++ c) res.next[color[u]][c] = color[next[u][c]];
			res.is_accepting_state[color[u]] = is_accepting_state[u];
		}
		return res;
	}
	// Returns the smallest automaton corresponding to the intersection of two regular languages
	DFA_t operator&(const DFA_t &aut) const{
		auto res = deterministic_finite_automaton(size() * aut.size());
		auto index = [&](int u, int v)->int{ return aut.size() * u + v; };
		res.initial_state = index(initial_state, aut.initial_state);
		for(auto u = 0; u < size(); ++ u) for(auto v = 0; v < aut.size(); ++ v){
			int id = index(u, v);
			for(auto c = 0; c < sigma; ++ c) res.next[id][c] = index(next[u][c], aut.next[v][c]);
			res.is_accepting_state[id] = is_accepting_state[u] & res.is_accepting_state[v];
		}
		return res.reduce();
	}
	// Returns the smallest automaton corresponding to the union of two regular languages
	DFA_t operator|(const DFA_t &aut) const{
		auto res = deterministic_finite_automaton(size() * aut.size());
		auto index = [&](int u, int v)->int{ return aut.size() * u + v; };
		res.initial_state = index(initial_state, aut.initial_state);
		for(auto u = 0; u < size(); ++ u) for(auto v = 0; v < aut.size(); ++ v){
			int id = index(u, v);
			for(auto c = 0; c < sigma; ++ c) res.next[id][c] = index(next[u][c], aut.next[v][c]);
			res.is_accepting_state[id] = is_accepting_state[u] | res.is_accepting_state[v];
		}
		return res.reduce();
	}
	// Returns the smallest automaton corresponding to the complementary regular language
	DFA_t operator~() const{
		auto dfa = *this;
		for(auto &x: dfa.is_accepting_state) x = !x;
		return dfa;
	}
	// Returns the smallest automaton corresponding to the relative-complementary regular language
	// i.e. the set of words in LHS not in RHS
	DFA_t set_difference(const DFA_t &aut) const{
		return *this & ~aut;
	}
	// Returns the smallest automaton corresponding to the concatenation of two regular languages
	DFA_t concat(const DFA_t &aut) const{
		assert(aut.size() < 30 && (long long)size() << aut.size() < numeric_limits<int>::max());
		auto res = deterministic_finite_automaton(size() << aut.size());
		auto index = [&](int u, int vmask)->int{ return u << aut.size() | vmask; };
		res.initial_state = index(initial_state, is_accepting_state[initial_state] ? 1 << aut.initial_state : 0);
		int accepting_mask = 0;
		for(auto v = 0; v < aut.size(); ++ v) if(aut.is_accepting_state[v]) accepting_mask |= 1 << v;
		for(auto u = 0; u < size(); ++ u) for(auto vmask = 0; vmask < 1 << aut.size(); ++ vmask){
			int id = index(u, vmask);
			for(auto c = 0; c < sigma; ++ c){
				int u_next = next[u][c];
				int vmask_next = 0;
				for(auto v = 0; v < aut.size(); ++ v) if(vmask >> v & 1) vmask_next |= 1 << aut.next[v][c];
				if(is_accepting_state[u_next]) vmask_next |= 1 << aut.initial_state;
				int id_next = index(u_next, vmask_next);
				res.next[id][c] = id_next;
			}
			if(vmask & accepting_mask) res.is_accepting_state[id] = true;
		}
		return res.reduce();
	}
	// TODO: finish these
	// DFA_t Kleene_star() const{

	// }
	// DFA_t Kleene_plus() const{

	// }
	// DFA_t reverse() const{

	// }
	// // Returns the smallest automaton corresponding to the quotient of two regular languages
	// DFA_t quotient(const DFA_t &aut) const{

	// }
	// DFA_t substitution(int from, const vector<int> &to) const{

	// }
	// DFA_t homomorphism(const array<vector<int>, sigma> &to) const{

	// }
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>deterministic_finite_automaton</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
