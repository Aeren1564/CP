<snippet>
	<content><![CDATA[
template<class Key_t, class Value_t>
struct line_segment_container{
#ifdef LOCAL
	#define ASSERT(x) assert(x)
#else
	#define ASSERT(x) 42
#endif
	// Keeps track of integer points with x coordinates on [left_boundary, right_boundary]
	Key_t left_boundary, right_boundary;
	Value_t initial_value;
	map<Key_t, Value_t> second_derivative;
	line_segment_container(
		Key_t left_boundary = numeric_limits<Key_t>::min(),
		Key_t right_boundary = numeric_limits<Key_t>::max(),
		Value_t initial_value = 0,
		Value_t initial_slope = 0
	): left_boundary(left_boundary), right_boundary(right_boundary), initial_value(initial_value){
		ASSERT(left_boundary <= right_boundary);
		_update(left_boundary, initial_slope);
	}
	void clear(
		Key_t left_boundary = numeric_limits<Key_t>::min(),
		Key_t right_boundary = numeric_limits<Key_t>::max(),
		Value_t initial_value = 0,
		Value_t initial_slope = 0
	){
		this->left_boundary = left_boundary;
		this->right_boundary = right_boundary;
		this->initial_value = initial_value;
		second_derivative.clear();
		_update(left_boundary, initial_slope);
	}
	void _update(Key_t x, Value_t slope_dif){
		ASSERT(left_boundary <= x && x <= right_boundary);
		if(slope_dif && (second_derivative[x] += slope_dif) == 0) second_derivative.erase(x);
	}
	// Add value + slope * (x - l) at x for each l <= x <= r
	void add(Key_t l, Key_t r, Value_t value, Value_t slope){
		ASSERT(left_boundary <= l && l <= r && r <= right_boundary);
		if(l == r){
			if(l == left_boundary){
				initial_value += value;
				_update(l, -value);
			}
			else{
				_update(l - 1, value);
				_update(l, -2 * value);
			}
			if(l + 1 <= right_boundary) _update(l + 1, value);
		}
		else{
			if(left_boundary == l){
				initial_value += value;
				_update(l, slope);
			}
			else{
				_update(l - 1, value);
				_update(l, slope - value);
			}
			value += slope * (r - l);
			_update(r, -value - slope);
			if(r + 1 <= right_boundary) _update(r + 1, value);
		}
	}
	// Add value_reversed - slope * (r - x) at x for each l <= x <= r
	void add_reversed(Key_t l, Key_t r, Value_t value_reversed, Value_t slope){
		add(l, r, value_reversed - slope * (r - l), slope);
	}
	// Split [l, r] into maximal intervals [p_0=l, p_1], [p_1, p_2], ..., [p_{k-2}, p_{k-1}=r]
	// such that p_i < p_{i+1} and each interval has constant slope
	// Call process(p_i, p_{i+1}, value at p_i, slope) for each such intervals in increasing order of i
	void iterate_all_line_segments(Key_t l, Key_t r, auto process) const{
		ASSERT(left_boundary <= l && l <= r && r <= right_boundary);
		if(l == r) return;
		Key_t pos = left_boundary;
		Value_t value = initial_value;
		Value_t slope = 0;
		auto it = second_derivative.begin();
		if(it != second_derivative.end() && it->first == initial_value){
			slope = it->second;
			++ it;
		}
		for(; it != second_derivative.end() && it->first <= l; ++ it){
			value += slope * (it->first - pos);
			slope += it->second;
			pos = it->first;
		}
		value += slope * (l - pos);
		pos = l;
		for(; it != second_derivative.end() && it->first < r; ++ it){
			process(pos, it->first, value, slope);
			value += slope * (it->first - pos);
			slope += it->second;
			pos = it->first;
		}
		process(pos, r, value, slope);
	}
	friend ostream &operator<<(ostream &out, const line_segment_container &lsc){
		out << "\n";
		bool from_found = false;
		Key_t from = lsc.left_boundary;
		Key_t to = lsc.left_boundary;
		lsc.iterate_all_line_segments(lsc.left_boundary, lsc.right_boundary, [&](Key_t l, Key_t r, Value_t value, Value_t slope){
			out << "[" << l << ", " << r << "]: " << value << " + " << slope << " * (x - " << l << ")\n";
			if(value || slope){
				if(!from_found){
					from_found = true;
					from = l;
				}
				to = r;
			}
		});
		vector<Value_t> a(to - from + 1);
		lsc.iterate_all_line_segments(lsc.left_boundary, lsc.right_boundary, [&](Key_t l, Key_t r, Value_t value, Value_t slope){
			if(from <= l && r <= to) for(auto i = l; i <= r; ++ i) a[i - from] = value + slope * (i - l);
		});
		out << "A[" << from << "~" << to << "]: {";
		for(auto i = 0; i <= to - from; ++ i){
			out << a[i];
			if(i + 1 <= to - from) out << ", ";
		}
		return out << "}";
	}
#undef ASSERT
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>line_segment_container</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<!-- <scope>source.python</scope> -->
</snippet>
