<snippet>
	<content><![CDATA[
template<bool IS_INVERTIBLE, class T, class F, class I>
struct static_range_query_processor_3d_base{
#ifdef LOCAL
	#define ASSERT(x) assert(x);
#else
	#define ASSERT(x) 42
#endif
	int n, m, o;
	array<vector<vector<vector<T>>>, 4> data;
	F TT;   // must be commutative
	T T_id;
	I Tinv;
	static_range_query_processor_3d_base(F TT, T T_id, I Tinv): TT(TT), T_id(T_id), Tinv(Tinv){ }
	static_range_query_processor_3d_base &operator=(const static_range_query_processor_3d_base &srq){
		n = srq.n;
		m = srq.m;
		data = srq.data;
		return *this;
	}
	// O(n)
	template<class U>
	void build(int n, int m, int o, const vector<vector<vector<T>>> &a){
		ASSERT(0 <= n && 0 <= m && 0 <= o);
		this->n = n;
		this->m = m;
		this->o = o;
		ASSERT((int)a.size() == n);
		for(const auto &plane: a){
			ASSERT((int)plane.size() == m);
			for(const auto &row: plane) ASSERT((int)row.size() == o);
		}
		for(auto mask = 0; mask < (IS_INVERTIBLE ? 8 : 1); ++ mask){
			data[mask].assign(n + 1, vector(m + 1, vector<T>(o + 1, T_id)));
			int iv = mask >> 2 & 1;
			int istart = !iv ? 0 : n - 1;
			int iend = !iv ? n : -1;
			int istep = !iv ? 1 : -1;
			int jv = mask >> 1 & 1;
			int jstart = !jv ? 0 : m - 1;
			int jend = !jv ? m : -1;
			int jstep = !jv ? 1 : -1;
			int kv = mask & 1;
			int kstart = !kv ? 0 : o - 1;
			int kend = !kv ? o : -1;
			int kstep = !kv ? 1 : -1;
			for(auto i = 0; i < n; ++ i)
				for(auto j = 0; j < m; ++ j)
					for(auto k = 0; k < o; ++ k)
						data[mask][i + !iv][j + !jv][k + !kv] = a[i][j][k];
			for(auto i = 0; i <= n; ++ i)
				for(auto j = 0; j <= m; ++ j)
					for(auto k = kstart; k != kend; k += kstep)
						data[mask][i][j][k + !kv] = TT(data[mask][i][j][k + !kv], data[mask][i][j][k + kv]);
			for(auto j = 0; j <= m; ++ j)
				for(auto k = 0; k <= o; ++ k)
					for(auto i = istart; i != iend; i += istep)
						data[mask][i + !iv][j][k] = TT(data[mask][i + !iv][j][k], data[mask][i + iv][j][k]);
			for(auto k = 0; k <= o; ++ k)
				for(auto i = 0; i <= n; ++ i)
					for(auto j = jstart; j != jend; j += jstep)
						data[mask][i][j + !jv][k] = TT(data[mask][i][j + !jv][k], data[mask][i][j + jv][k]);
		}
	}
	// O(n)
	void build(int n, int m, int o, auto f){
		ASSERT(0 <= n && 0 <= m && 0 <= o);
		vector a(n, vector(m, vector<T>(o)));
		for(auto i = 0; i < n; ++ i) for(auto j = 0; j < m; ++ j) for(auto k = 0; k < o; ++ k) a[i][j][k] = f(i, j, k);
		build(n, m, o, a);
	}
	// O(1)
	T prepreprefix(int xr, int yr, int zr) const{
		ASSERT(0 <= xr && xr <= n && 0 <= yr && yr <= m && 0 <= zr && zr <= o);
		return data[0][xr][yr][zr];
	}
	// O(1)
	T query(int xl, int xr, int yl, int yr, int zl, int zr) const{
		static_assert(IS_INVERTIBLE);
		ASSERT(0 <= xl && xl <= xr && xr <= n && 0 <= yl && yl <= yr && yr <= m && 0 <= zl && zl <= zr && zr <= o);
		return TT(
			TT(
				TT(Tinv(data[0][xl][yl][zl]), data[0][xl][yl][zr]),
				TT(data[0][xl][yr][zl], Tinv(data[0][xl][yr][zr]))
			),
			TT(
				TT(data[0][xr][yl][zl], Tinv(data[0][xr][yl][zr])),
				TT(Tinv(data[0][xr][yr][zl]), data[0][xr][yr][zr])
			)
		);
	}
#undef ASSERT
};

// Can perform arbitrary range query
template<class T, class F, class I>
auto make_invertible_static_range_query_processor_3d(F TT, T T_id, I Tinv){
	return static_range_query_processor_3d_base<true, T, F, I>(TT, T_id, Tinv);
}
template<class T>
auto make_range_sum_query_processor_3d(T T_id = T{0}){
	return static_range_query_processor_3d_base<true, T, plus<>, negate<>>(plus{}, T_id, negate{});
}
template<class T>
auto make_range_product_query_processor_3d(T T_id = T{1}){
	auto mul_inv = [](const T &x){ return T{1} / x; };
	return static_range_query_processor_3d_base<true, T, multiplies<>, decltype(mul_inv)>(multiplies{}, T_id, mul_inv);
}
template<class T>
auto make_range_xor_query_processor_3d(T T_id = T{0}){
	return static_range_query_processor_3d_base<true, T, bit_xor<>, identity>(bit_xor{}, T_id, identity{});
}
// Can perform prefix and suffix query
template<class T, class F>
auto make_singular_static_range_query_processor_3d(F TT, T T_id){
	auto _inv = [&](){ assert(false); };
	return static_range_query_processor_3d_base<false, T, F, decltype(_inv)>(TT, T_id, _inv);
}
template<class T>
auto make_range_min_query_processor_3d(T T_id = numeric_limits<T>::max() / 2){
	auto TT = [](const T &x, const T &y){ return min(x, y); };
	auto _inv = [](){ assert(false); };
	return static_range_query_processor_3d_base<false, T, decltype(TT), decltype(_inv)>(TT, T_id, _inv);
}
template<class T>
auto make_range_max_query_processor_3d(T T_id = numeric_limits<T>::min() / 2){
	auto TT = [](const T &x, const T &y){ return max(x, y); };
	auto _inv = [](){ assert(false); };
	return static_range_query_processor_3d_base<false, T, decltype(TT), decltype(_inv)>(TT, T_id, _inv);
}
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>static_range_query_processor_3d</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
