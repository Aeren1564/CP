<snippet>
	<content><![CDATA[
// Requires graph
struct small_to_large_on_forest{
#ifdef LOCAL
	#define ASSERT(x) assert(x)
#else
	#define ASSERT(x) 42
#endif
	int n;
	vector<vector<int>> adj;
	vector<int> size, pv, pe, order, pos, end, root;
	small_to_large_on_forest(){ }
	template<class T>
	small_to_large_on_forest(const graph<T> &g){ build_all(g); }
	template<class T>
	small_to_large_on_forest(const graph<T> &g, const vector<int> &roots){ build(g, roots); }
	void _init(int n){
		this->n = n;
		adj.resize(n);
		size.resize(n);
		pv.resize(n);
		pe.resize(n);
		order.clear();
		pos.resize(n);
		end.resize(n);
		root.resize(n);
		was.resize(n, -2);
	}
	int attempt = -1;
	vector<int> was;
	template<class T>
	void build_all(const graph<T> &g){
		vector<int> roots(g.n);
		iota(roots.begin(), roots.end(), 0);
		build(g, roots);
	}
	template<class T>
	void build(const graph<T> &g, const vector<int> &roots){
		_init(g.n);
		++ attempt;
		auto dfs_size = [&](auto self, int u)->void{
			was[u] = attempt;
			adj[u].clear();
			size[u] = 1;
			for(auto id: g.adj[u]){
				if(g.ignore && g.ignore(id)) continue;
				auto &e = g.edge[id];
				int v = u ^ e.from ^ e.to;
				if(was[v] == attempt) continue;
				pv[v] = u;
				pe[v] = id;
				root[v] = root[u];
				self(self, v);
				size[u] += size[v];
				adj[u].push_back(v);
				if(size[adj[u][0]] < size[v]) swap(adj[u].front(), adj[u].back());
			}
		};
		auto dfs = [&](auto self, int u)->void{
			pos[u] = (int)order.size();
			order.push_back(u);
			for(auto v: adj[u]) self(self, v);
			end[u] = (int)order.size();
		};
		for(auto u: roots) if(was[u] != attempt){
			root[u] = u;
			pv[u] = pe[u] = -1;
			dfs_size(dfs_size, u);
			dfs(dfs, u);
		}
	}
	// Check if u is visited during the last build-like call.
	bool visited(int u) const{
		ASSERT(0 <= u && u < n);
		return was[u] == attempt;
	}
	// Returns all vertices in the subtree of u in dfs order
	auto subtr(int u){
		ASSERT(visited(u));
		return order | views::take(end[u]) | views::drop(pos[u]);
	}
	// insert_subtr(u): insert all vertices in the subtree of u into the state.
	// insert_root(u): insert vertex u into the state.
	// answer(u, flag): answer for the subtree of u, flag indicates whether u is included or not.
	// clear_subtr(u): erase every vertex in the subtree of u from the state.
	// Sum of subtree sizes of u over all insert_subtr(u) calls is O(n * log(n)).
	// insert_root(u), answer(u, false), and answer(u, true) are called once for each u.
	// Sum of subtree size of vertex u for all clear_subtr(u) calls is O(n).
	void run(auto insert_subtr, auto insert_root, auto clear_subtr, auto answer){
		for(auto r: order) if(root[r] == r) for(auto i = end[r] - 1; i >= pos[r]; -- i){
			int u = order[i];
			for(auto j = 1; j < (int)adj[u].size(); ++ j) insert_subtr(adj[u][j]);
			answer(u, false), insert_root(u), answer(u, true);
			if(!~pv[u] || adj[pv[u]][0] != u) clear_subtr(u);
		}
	}
#undef ASSERT
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>small_to_large_on_forest</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
