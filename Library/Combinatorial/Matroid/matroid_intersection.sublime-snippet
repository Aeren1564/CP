<snippet>
	<content><![CDATA[
template<class F1, class F2, class F3, class F4, class F5, class F6>
struct matroid_intersection_base{
	int n;
	vector<int> used;
	vector<int> pv, q;
	// 1st matroid
	F1 check1;  // check1(int i): check if (I U {i}) is still independent
	F2 insert1; // insert1(int i): set I <- I U {i}, only gets called when the result is independent
	F3 clear1;  // clear1(): set I <- \emptyset
	// 2nd matroid
	F4 check2;  // check1(int i): check if (I U {i}) is still independent
	F5 insert2; // insert1(int i): set I <- I U {i}, only gets called when the result is independent
	F6 clear2;  // clear1(): set I <- \emptyset
	matroid_intersection_base(F1 check1, F2 insert1, F3 clear1, F4 check2, F5 insert2, F6 clear2): check1(check1), insert1(insert1), clear1(clear1), check2(check2), insert2(insert2), clear2(clear2){ }
	bool augment(){
		fill(pv.begin(), pv.end(), -1);
		int qend = 0;
		q[qend ++] = n;
		auto forward_edge = [&](int u){
			vector<int> res;
			clear1();
			for(auto v = 0; v < n; ++ v) if(used[v] && v != u) insert1(v);
			for(auto v = 0; v < n; ++ v) if(!used[v] && !~pv[v] && check1(v)){
				res.push_back(v);
				pv[v] = u;
			}
			return res;
		};
		auto backward_edge = [&](int u){
			clear2();
			for(auto rep = 0; rep < 2; ++ rep) for(auto v = 0; v < n; ++ v) if((v == u || used[v]) && !~pv[v] == rep){
				if(!check2(v)){
					if(rep){
						q[qend ++] = v;
						pv[v] = u;
						return v;
					}
					else return -1;
				}
				insert2(v);
			}
			return n;
		};
		for(auto qbeg = 0; qbeg < qend; ++ qbeg){
			int u = q[qbeg], v;
			for(auto w: forward_edge(u)) while(~(v = backward_edge(w))) if(v == n){
				for(; w != n; w = pv[w]) used[w] ^= 1;
				return true;
			}
		}
		return false;
	}
	void _init(int n){
		this->n = n;
		used.resize(n);
		pv.resize(n);
		q.resize(n + 1);
	}
	/*
	-----------------------------------------
	| # of member function calls where      |
	| r is the size of the answer and       |
	| N is the size of the ground set       |
	-----------------------------------------
	| Function  | 1st Matroid | 2nd Matroid |
	-----------------------------------------
	| insert()  | O(r^3)      | O(r^2 * n)  |
	| check()   | O(r^2 * n)  | O(r^2 * n)  |
	| clear()   | O(r^2)      | O(r * n)    |
	-----------------------------------------
	*/
	vector<int> maximum_common_independent_set(int n){
		_init(n);
		fill(used.begin(), used.end(), false);
		clear1(), clear2();
		for(auto u = 0; u < n; ++ u) if(check1(u) && check2(u)) used[u] = true, insert1(u), insert2(u);
		while(augment());
		vector<int> res;
		for(auto u = 0; u < n; ++ u) if(used[u]) res.push_back(u);
		return res;
	}
};

template<class F1, class F2, class F3, class F4, class F5, class F6>
auto make_matroid_intersection(F1 check1, F2 insert1, F3 clear1, F4 check2, F5 insert2, F6 clear2){
	return matroid_intersection_base<F1, F2, F3, F4, F5, F6>(check1, insert1, clear1, check2, insert2, clear2);
}
// auto M = make_matroid_intersection(check1, insert1, clear1, check2, insert2, clear2);
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>matroid_intersection</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
