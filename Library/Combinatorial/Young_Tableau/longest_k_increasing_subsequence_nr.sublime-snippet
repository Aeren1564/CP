<snippet>
	<content><![CDATA[
// k-increasing subsequence is a subsequence that is a union of k increasing subsequences
// Source: An Extension of Schensted's Theorem (Curtis Greene)
// Returns a 2d array representing a partition of k-increasing subsequence of maximum length into k increasing subsequences in the given array
// p must be a permutation
// O(n * (k * log(n) + r)) where r is the length of the answer
template<class Compare = less<>>
vector<vector<int>> longest_k_increasing_subsequence_nr(const vector<int> &p, int k, Compare cmp = less{}){
	static_assert((is_same_v<less<>, decltype(cmp)> || is_same_v<greater<>, decltype(cmp)>));
	assert(1 <= k && k <= (int)p.size());
	if constexpr(is_same_v<greater<>, decltype(cmp)>){
		vector<int> p2((int)p.size());
		for(auto i = 0; i < (int)p.size(); ++ i) p2[i] = (int)p.size() - 1 - p[i];
		return longest_k_increasing_subsequence_nr(p2, k, less{});
	}
	int n = (int)p.size();
	vector<int> pos(n, -1);
	for(auto i = 0; i < n; ++ i){
		assert(0 <= p[i] && p[i] < n && !~pos[p[i]]);
		pos[p[i]] = i;
	}
	vector<array<int, 3>> swaps;
	vector<vector<int>> s;
	for(auto x: p){
		bool found = false;
		for(auto i = 0; i < min(k, (int)s.size()); ++ i){
			int j = upper_bound(s[i].begin(), s[i].end(), x) - s[i].begin();
			if(j == (int)s[i].size()){
				s[i].push_back(x);
				found = true;
				break;
			}
			for(auto jj = (int)s[i].size() - 1; jj > j; -- jj) swaps.push_back({x, s[i][jj - 1], s[i][jj]});
			swap(s[i][j], x);
		}
		if(!found && (int)s.size() < k) s.emplace_back(vector<int>{x});
	}
	vector<int> next(n + 1, -1), prev(n + 1, -1);
	for(auto i = 0; i < (int)s.size(); ++ i){
		prev[s[i].front()] = n;
		for(auto j = 0; j < (int)s[i].size() - 1; ++ j){
			next[s[i][j]] = s[i][j + 1];
			prev[s[i][j + 1]] = s[i][j];
		}
		next[s[i].back()] = n;
	}
	reverse(swaps.begin(), swaps.end());
	for(auto [x, y, z]: swaps){ // yxz->yzx
		if(next[x] != z) continue;
		if(!~next[y]){
			prev[y]= prev[x], next[prev[y]] = y;
			next[y] = z, prev[z] = y;
			prev[x] = next[x] = -1;
		}
		else{
			next[x] = next[y], prev[next[x]] = x;
			next[y] = z, prev[z] = y;
		}
	}
	vector<vector<int>> partition(k);
	vector<int> seq(n, -1);
	for(auto x = 0, it = 0; x < n; ++ x) if(~prev[x]){
		seq[x] = prev[x] == n ? it ++ : seq[prev[x]];
		partition[seq[x]].push_back(pos[x]);
	}
	return partition;
}

// Returns the indices of a subsequence of p of length subseq_len whose longest increasing subsequence has length exactly k
template<class Compare = less<>>
optional<vector<int>> find_a_subsequence_with_LIS_length_k(const vector<int> &p, int subseq_len, int k, Compare cmp = less{}){
	static_assert((is_same_v<less<>, decltype(cmp)> || is_same_v<greater<>, decltype(cmp)>));
	assert(1 <= k && k <= subseq_len);
	vector<vector<int>> partition;
	if constexpr(is_same_v<less<>, decltype(cmp)>) partition = longest_k_increasing_subsequence_nr(p, k, greater{});
	else partition = longest_k_increasing_subsequence_nr(p, k, less{});
	if(partition.back().empty()) return {};
	vector<int> ind;
	for(auto part: partition) ind.insert(ind.end(), part.begin(), part.end());
	int cur_len = (int)ind.size();
	if(cur_len < subseq_len) return {};
	ranges::sort(ind);
	if(cur_len > subseq_len){
		vector<int> prev((int)ind.size()), active;
		for(auto i = 0; i < (int)ind.size(); ++ i){
			auto it = partition_point(active.begin(), active.end(), [&](int j){ return cmp(p[ind[j]], p[ind[i]]); });
			if(it == active.end()) active.emplace_back(), it = std::prev(active.end());
			*it = i;
			prev[i] = it == active.begin() ? -1 : *std::prev(it);
		}
		vector<int> in_lis((int)p.size()), res;
		for(auto len = (int)active.size(), cur = active.back(); len --; ) in_lis[ind[cur]] = true, cur = prev[cur];
		for(auto i: ind){
			if(in_lis[i] || cur_len == subseq_len) res.push_back(i);
			else -- cur_len;
		}
		ind = res;
	}
	assert((int)ind.size() == subseq_len);
	return ind;
}
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>longest_k_increasing_subsequence_nr</tabTrigger> -->
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<scope>source.c++</scope> -->
</snippet>
