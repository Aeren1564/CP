{
    "scope":"source.c++",
    "completions":
    [
        { "trigger": "trav", "contents": "for(auto $1: $2){\n\t$0\n}"},
        { "trigger": "forgeneral", "contents": "for($1; $2; $3){\n\t$0\n}"},
        { "trigger": "for", "contents": "for(auto ${1:i} = ${2:0}; $1 < ${3:n}; ${4:++ $1}){\n\t$0\n}"},
        { "trigger": "rof", "contents": "for(auto ${1:i} = ${2:n - 1}; $1 >= ${3:0}; ${4:-- $1}){\n\t$0\n}"},
        { "trigger": "forq", "contents": "for(auto ${1:qi} = ${2:0}; $1 < ${3:qn}; ${4:++ $1}){\n\t$0\n}"},
        { "trigger": "rep", "contents": "for(auto ${1:_}: views::iota(0, ${2:n})){\n\t$0\n}"},
        { "trigger": "forinf", "contents": "for(auto ${1:i}: views::iota(${2:0})){\n\t$0\n}"},
        { "trigger": "forenum", "contents": "for(auto [${1:i, x}]: $2 | views::enumerate){\n\t$0\n}"},
        { "trigger": "forbitset", "contents": "for(auto ${1:u} = $2._Find_first(); ${1:u} < ${3:n}; ${1:u} = $2._Find_next(${1:u})){\n\t$0\n}"},
        { "trigger": "fordr", "contents": "for(auto [d${1:i}, d${2:j}]: dr){\n\tint $1n = $1 + d$1, $2n = $2 + d$2;\n\tif(0 <= min($1n, $2n) && $1n < ${3:n} && $2n < ${4:m}){\n\t\t$0\n\t}\n}"},
        { "trigger": "while", "contents": "while($1){\n\t$0\n}"},
        { "trigger": "dowhile", "contents": "do{\n\t$0\n}while($1);"},
        { "trigger": "if", "contents": "if($1){\n\t$0\n}"},
        { "trigger": "else", "contents": "else{\n\t$0\n}"},

        { "trigger": "midpoint", "contents": "midpoint($1, $2)"},
        { "trigger": "lerp", "contents": "lerp($1, $2, $3)"},

        { "trigger": "bind_front", "contents": "bind_front($1, $2)"},

        { "trigger": "to", "contents": "ranges::to<${1:vector}>($2)"},
        { "trigger": "subrange", "contents": "ranges::subrange($1, $2)"},

        { "trigger": "vempty", "contents": "views::empty()"},
        { "trigger": "vsingle", "contents": "views::single($1)"},
        { "trigger": "viota", "contents": "views::iota($1, $2)"},
        { "trigger": "vrepeat", "contents": "views::repeat($1, $2)"},
        { "trigger": "vistream", "contents": "views::istream($1)"},

        { "trigger": "vfilter", "contents": "views::filter($1)"},
        { "trigger": "vtransform", "contents": "views::transform($1)"},
        { "trigger": "vtake", "contents": "views::take($1)"},
        { "trigger": "vtakewhile", "contents": "views::take_while($1)"},
        { "trigger": "vdrop", "contents": "views::drop($1)"},
        { "trigger": "vdropwhile", "contents": "views::drop_while($1)"},
        { "trigger": "vjoin", "contents": "views::join"},
        { "trigger": "vjoin_with", "contents": "views::join_with($1)"},
        { "trigger": "vlazysplit", "contents": "views::lazy_split($1)"},
        { "trigger": "vsplit", "contents": "views::split($1)"},
        { "trigger": "vconcat", "contents": "views::concat($1)", "annotation": "C++26"},
        { "trigger": "vreverse", "contents": "views::reverse"},
        { "trigger": "velements", "contents": "views::elements<$1>"},
        { "trigger": "vkeys", "contents": "views::keys"},
        { "trigger": "vvalues", "contents": "views::values"},
        { "trigger": "venumerate", "contents": "views::enumerate", "annotation": "C++23"},
        { "trigger": "vzip", "contents": "views::zip($1)", "annotation": "C++23"},
        { "trigger": "vzip_transform", "contents": "views::zip_transform($1, $2)", "annotation": "C++23"},
        { "trigger": "vpairwise", "contents": "views::pairwise", "annotation": "C++23"},
        { "trigger": "vadjacent", "contents": "views::adjacent<${1:3}>", "annotation": "C++23"},
        { "trigger": "vpairwise_transform", "contents": "views::pairwise_transform($1)", "annotation": "C++23"},
        { "trigger": "vadjacent_transform", "contents": "views::adjacent_transform<${1:3}>($2)", "annotation": "C++23"},
        { "trigger": "vchunk", "contents": "views::chunk($1)", "annotation": "C++23"},
        { "trigger": "vslide", "contents": "views::slide($1)", "annotation": "C++23"},
        { "trigger": "vchunk_by", "contents": "views::chunk_by($1)", "annotation": "C++23"},
        { "trigger": "vstride", "contents": "views::stride($1)", "annotation": "C++23"},
        { "trigger": "vcartesian_product", "contents": "views::cartesian_product($1)", "annotation": "C++23"},
        { "trigger": "vcache_latest", "contents": "views::cache_latest", "annotation": "C++26"},

        { "trigger": "input", "contents": "copy_n(istream_iterator<${1:int}>(cin), ${2:n}, $3.begin())"},
        { "trigger": "output", "contents": "ranges::copy($1, ostream_iterator<${2:int}>(${3:cout}, ${4:\" \"}))"},

        { "trigger": "iota", "contents": "ranges::iota($1, ${2:0})"},
        { "trigger": "all_of", "contents": "ranges::all_of($1, ${2:identity()})"},
        { "trigger": "any_of", "contents": "ranges::any_of($1, ${2:identity()})"},
        { "trigger": "none_of", "contents": "ranges::none_of($1, ${2:identity()})"},
        { "trigger": "for_each", "contents": "ranges::for_each($1, $2, $3)"},
        { "trigger": "for_each_n", "contents": "ranges::for_each_n($1, $2, $3)"},
        { "trigger": "count", "contents": "ranges::count($1)"},
        { "trigger": "count_if", "contents": "ranges::count_if($1, ${2:identity()})"},
        { "trigger": "mismatch", "contents": "ranges::mismatch($1)"},
        { "trigger": "equal", "contents": "ranges::equal($1, $2)"},
        { "trigger": "lexicographical_compare", "contents": "ranges::lexicographical_compare($1)"},
        { "trigger": "find", "contents": "ranges::find($1)"},
        { "trigger": "find_if", "contents": "ranges::find_if($1)"},
        { "trigger": "find_if_not", "contents": "ranges::find_if_not($1)"},
        { "trigger": "find_last", "contents": "ranges::find($1)"},
        { "trigger": "find_last_if", "contents": "ranges::find_if($1)"},
        { "trigger": "find_last_if_not", "contents": "ranges::find_if_not($1)"},
        { "trigger": "find_end", "contents": "ranges::find_$1.end()"},
        { "trigger": "find_first_of", "contents": "ranges::find_first_of($1)"},
        { "trigger": "adjacent_find", "contents": "ranges::adjacent_find($1)"},
        { "trigger": "search", "contents": "ranges::search($1)"},
        { "trigger": "search_n", "contents": "ranges::search_n($1)"},
        { "trigger": "contains", "contents": "ranges::contains($1)"},
        { "trigger": "contains_subrange", "contents": "ranges::contains_subrange($1)"},
        { "trigger": "starts_with", "contents": "ranges::starts_with($1)"},
        { "trigger": "ends_with", "contents": "ranges::ends_with($1)"},

        { "trigger": "copy", "contents": "ranges::copy($1)"},
        { "trigger": "copy_if", "contents": "ranges::copy_if($1)"},
        { "trigger": "copy_n", "contents": "ranges::copy_n($1)"},
        { "trigger": "copy_backward", "contents": "ranges::copy_backward($1)"},
        { "trigger": "move", "contents": "ranges::move($1)"},
        { "trigger": "move_backward", "contents": "ranges::move_backward($1)"},
        { "trigger": "fill", "contents": "ranges::fill($1)"},
        { "trigger": "fill_n", "contents": "ranges::fill_n($1)"},
        { "trigger": "transform", "contents": "ranges::transform($1)"},
        { "trigger": "generate", "contents": "ranges::generate($1, ${2:rng})"},
        { "trigger": "generate_n", "contents": "ranges::generate_n($1, ${2:rng})"},
        { "trigger": "remove", "contents": "ranges::remove($1, $2)"},
        { "trigger": "remove_if", "contents": "ranges::remove_if($1, $2)"},
        { "trigger": "remove_copy", "contents": "ranges::remove_copy($1, $2, $3)"},
        { "trigger": "remove_copy_if", "contents": "ranges::remove_copy_if($1, $2, $3)"},
        { "trigger": "replace", "contents": "ranges::replace($1, $2, $3, $4)"},
        { "trigger": "replace_if", "contents": "ranges::replace_if($1, $2, $3, $4)"},
        { "trigger": "swap_ranges", "contents": "ranges::swap_ranges($1, $2)"},
        { "trigger": "reverse", "contents": "ranges::reverse($1)"},
        { "trigger": "reverse_copy", "contents": "ranges::reverse_copy($1, $2)"},
        { "trigger": "rotate", "contents": "ranges::rotate($1, $2)"},
        { "trigger": "rotate_copy", "contents": "ranges::rotate($1, $2, $3)"},
        { "trigger": "shuffle", "contents": "ranges::shuffle($1, ${2:rng})"},
        { "trigger": "shift_left", "contents": "ranges::shift_left($1)"},
        { "trigger": "shift_right", "contents": "ranges::shift_right($1)"},
        { "trigger": "sample", "contents": "ranges::sample($1, $2, $3, ${4:rng})"},
        { "trigger": "unique", "contents": "$1.erase(ranges::unique($1).begin(), $1.end())"},

        { "trigger": "is_partitioned", "contents": "ranges::is_partitioned($1)"},
        { "trigger": "partition", "contents": "ranges::partition($1)"},
        { "trigger": "partition_copy", "contents": "ranges::partition_copy($1)"},
        { "trigger": "stable_partition", "contents": "ranges::stable_partition($1)"},
        { "trigger": "partition_point", "contents": "ranges::partition_point($1)"},

        { "trigger": "is_sorted", "contents": "ranges::is_sorted($1)"},
        { "trigger": "is_sorted_until", "contents": "ranges::is_sorted_until($1)"},
        { "trigger": "sort", "contents": "ranges::sort($1)"},
        { "trigger": "partial_sort", "contents": "ranges::partial_sort($1)"},
        { "trigger": "partial_sort_copy", "contents": "ranges::partial_sort_copy($1)"},
        { "trigger": "stable_sort", "contents": "ranges::stable_sort($1)"},
        { "trigger": "nth_element", "contents": "ranges::nth_element($1)"},

        { "trigger": "lower_bound", "contents": "ranges::lower_bound($1)"},
        { "trigger": "upper_bound", "contents": "ranges::upper_bound($1)"},
        { "trigger": "binary_search", "contents": "ranges::binary_search($1)"},
        { "trigger": "equal_range", "contents": "ranges::equal_range($1)"},

        { "trigger": "merge", "contents": "ranges::merge($1, $2, $3)"},
        { "trigger": "inplace_merge", "contents": "ranges::inplace_merge($1, $2)"},
        { "trigger": "includes", "contents": "ranges::includes($1, $2)"},
        { "trigger": "set_difference", "contents": "ranges::set_difference($1, $2, $3)"},
        { "trigger": "set_intersection", "contents": "ranges::set_intersection($1, $2, $3)"},
        { "trigger": "set_symmetric_difference", "contents": "ranges::set_symmetric_difference($1, $2, $3)"},
        { "trigger": "set_union", "contents": "ranges::set_union($1, $2, $3)"},

        { "trigger": "max", "contents": "ranges::max($1)"},
        { "trigger": "max_element", "contents": "ranges::max_element($1)"},
        { "trigger": "min", "contents": "ranges::min($1)"},
        { "trigger": "min_element", "contents": "ranges::min_element($1)"},
        { "trigger": "minmax", "contents": "ranges::minmax($1)"},
        { "trigger": "minmax_element", "contents": "ranges::minmax_element($1)"},

        { "trigger": "is_permutation", "contents": "ranges::is_permutation($1)"},
        { "trigger": "next_permutation", "contents": "ranges::next_permutation($1).found"},
        { "trigger": "prev_permutation", "contents": "ranges::prev_permutation($1).found"},

        { "trigger": "lfold", "contents": "ranges::fold_left($1, ${2:0LL}, ${3:plus{}})"},
        { "trigger": "rfold", "contents": "ranges::fold_right($1, ${2:0LL}, ${3:plus{}})"},

        { "trigger": "inserter", "contents": "inserter($1, $2)"},
        { "trigger": "back_inserter", "contents": "back_inserter($1)"},
        { "trigger": "front_inserter", "contents": "front_inserter($1)"},
        
        { "trigger": "popcount\tCount the number of 1s", "contents": "__builtin_popcount$1($2)"},
        { "trigger": "parity\tGet the parity", "contents": "__builtin_parity$1($2)"},
        { "trigger": "clz\tCount the number of leading zeros", "contents": "__builtin_clz$1($2)"},
        { "trigger": "ctz\tCount the number of trailing zeros", "contents": "__builtin_ctz$1($2)"},
        { "trigger": "ffs\tReturn the position of the first set bit", "contents": "__builtin_ffs$1($2)"},
        { "trigger": "clrsb\tCount the number of leading redundant sign bits", "contents": "__builtin_clrsb$1($2)"},
        { "trigger": "addoverflow", "contents": "__builtin_add_overflow_p($1, $2, ${3:0})"},
        { "trigger": "muloverflow", "contents": "__builtin_mul_overflow_p($1, $2, ${3:0})"},
        { "trigger": "suboverflow", "contents": "__builtin_sub_overflow_p($1, $2, ${3:0})"},
        
        { "trigger": "plus", "contents": "plus{}"},
        { "trigger": "minus", "contents": "minus{}"},
        { "trigger": "multiplies", "contents": "multiplies{}"},
        { "trigger": "devides", "contents": "devides{}"},
        { "trigger": "modulus", "contents": "modulus{}"},
        { "trigger": "negate", "contents": "negate{}"},
        { "trigger": "equal_to", "contents": "equal_to{}"},
        { "trigger": "not_equal_to", "contents": "not_equal_to{}"},
        { "trigger": "greater", "contents": "greater{}"},
        { "trigger": "less", "contents": "less{}"},
        { "trigger": "greater_equal", "contents": "greater_equal{}"},
        { "trigger": "less_equal", "contents": "less_equal{}"},
        { "trigger": "logical_and", "contents": "logical_and{}"},
        { "trigger": "logical_or", "contents": "logical_or{}"},
        { "trigger": "logical_not", "contents": "logical_not{}"},
        { "trigger": "bit_and", "contents": "bit_and{}"},
        { "trigger": "bit_or", "contents": "bit_and{}"},
        { "trigger": "bit_xor", "contents": "bit_xor{}"},
        { "trigger": "bit_not", "contents": "bit_not{}"},
        { "trigger": "get", "contents": "get<$1>($2)"},

        { "trigger": "ll", "contents": "long long"},
        { "trigger": "ull", "contents": "unsigned long long"},
        { "trigger": "ld", "contents": "long double"},

        { "trigger": "ab", "contents": "array<bool, ${1:2}>"},
        { "trigger": "ai", "contents": "array<int, ${1:2}>"},
        { "trigger": "al", "contents": "array<long long, ${1:2}>"},
        { "trigger": "al", "contents": "array<double, ${1:2}>"},
        { "trigger": "am", "contents": "array<modular, ${1:2}>"},
        { "trigger": "as", "contents": "array<string, ${1:2}>"},
        { "trigger": "aab", "contents": "array<array<bool, ${2:2}>, ${1:2}>"},
        { "trigger": "aai", "contents": "array<array<int, ${2:2}>, ${1:2}>"},
        { "trigger": "aal", "contents": "array<array<long long, ${2:2}>, ${1:2}>"},
        { "trigger": "aad", "contents": "array<array<long long, ${2:2}>, ${1:2}>"},
        { "trigger": "aam", "contents": "array<array<modular, ${2:2}>, ${1:2}>"},
        { "trigger": "aas", "contents": "array<array<string, ${2:2}>, ${1:2}>"},

        { "trigger": "pii", "contents": "pair<int, int>"},
        { "trigger": "pil", "contents": "pair<int, long long>"},
        { "trigger": "pli", "contents": "pair<long long, int>"},
        { "trigger": "pll", "contents": "pair<long long, long long>"},

        { "trigger": "vb", "contents": "vector<bool>"},
        { "trigger": "vi", "contents": "vector<int>"},
        { "trigger": "vl", "contents": "vector<long long>"},
        { "trigger": "vd", "contents": "vector<double>"},
        { "trigger": "vm", "contents": "vector<modular>"},
        { "trigger": "vs", "contents": "vector<string>"},

        { "trigger": "vaii", "contents": "vector<array<int, 2>>"},
        { "trigger": "vpii", "contents": "vector<pair<int, int>>"},
        { "trigger": "vpil", "contents": "vector<pair<int, long long>>"},
        { "trigger": "vpli", "contents": "vector<pair<long long, int>>"},
        { "trigger": "val", "contents": "vector<array<long long, 2>>"},
        { "trigger": "vpll", "contents": "vector<pair<long long, long long>>"},
        { "trigger": "vvb", "contents": "vector<vector<bool>>"},
        { "trigger": "vvi", "contents": "vector<vector<int>>"},
        { "trigger": "vvl", "contents": "vector<vector<long long>>"},
        { "trigger": "vvd", "contents": "vector<vector<double>>"},
        { "trigger": "vvm", "contents": "vector<vector<modular>>"},
        { "trigger": "vvai", "contents": "vector<vector<array<int, 2>>>"},
        { "trigger": "vvpii", "contents": "vector<vector<pair<int, int>>>"},
        { "trigger": "vvpil", "contents": "vector<vector<pair<int, long long>>>"},
        { "trigger": "vvpli", "contents": "vector<vector<pair<long long, int>>>"},
        { "trigger": "vval", "contents": "vector<vector<array<long long, 2>>>"},
        { "trigger": "vvpll", "contents": "vector<vector<pair<long long, long long>>>"},
        { "trigger": "vvvi", "contents": "vector<vector<vector<int>>>"},
        { "trigger": "vvvl", "contents": "vector<vector<vector<long long>>>"},
        { "trigger": "vvvd", "contents": "vector<vector<vector<double>>>"},
        { "trigger": "vvvm", "contents": "vector<vector<vector<modular>>>"},
        { "trigger": "vvvai", "contents": "vector<vector<vector<array<int, 2>>>>"},
        { "trigger": "vvvpii", "contents": "vector<vector<vector<pair<int, int>>>>"},
        { "trigger": "va", "contents": "valarray<${1:int}>"},
        { "trigger": "pq", "contents": "priority_queue<$1>"},
        { "trigger": "gpq", "contents": "priority_queue<$1, vector<$1>, greater<>>"},
        { "trigger": "lambda", "contents": "[&]($1){ $2 }"},
        { "trigger": "function", "contents": "[&]($1)->${2:void}{\n\t$0\n};"},
        { "trigger": "recursion", "contents": "[&](this auto &&self, $1)->${2:void}{\n\t$0\n};"},
    
        { "trigger": "pushb", "contents": "push_back($1)" },
        { "trigger": "pushf", "contents": "push_front($1)" },
        { "trigger": "popb", "contents": "pop_back()"},
        { "trigger": "popf", "contents": "pop_front()"},
        { "trigger": "emplaceb", "contents": "emplace_back($1)" },
        { "trigger": "front", "contents": "front()"},
        { "trigger": "back", "contents": "back()"},
        { "trigger": "begin", "contents": "begin()"},
        { "trigger": "end", "contents": "end()"},
        { "trigger": "rbegin", "contents": "rbegin()"},
        { "trigger": "rend", "contents": "rend()"},
        { "trigger": "insert", "contents": "insert($1)"},
        { "trigger": "erase", "contents": "erase($1, $2)"},
        { "trigger": "erase_if", "contents": "erase_if($1, $2)"},
        { "trigger": "first", "contents": "first"},
        { "trigger": "second", "contents": "second"},
        { "trigger": "find_by_order", "contents": "find_by_order($1)"},
        { "trigger": "order_of_key", "contents": "order_of_key($1)"},
        { "trigger": "_Find_first", "contents": "_Find_first()"},
        { "trigger": "_Find_next", "contents": "_Find_next($1)"},

        { "trigger": "precision", "contents": "cout << fixed << setprecision(15);"},
        { "trigger": "mod1", "contents": "1e9 + 7"},
        { "trigger": "mod2", "contents": "(119 << 23) + 1"},
        { "trigger": "limit", "contents": "numeric_limits<${1:long long}>::${2:max}()"},
        { "trigger": "sz", "contents": "(int)$1.size()"},
        { "trigger": "kill", "contents": "auto kill = [](){\n\t${1:cout << -1;}\n\texit(0);\n};"},
        { "trigger": "iop", "contents": "istream &operator>>(istream &in, $1 &$2){\n\t${3:return in >> $2;}\n}"},
        { "trigger": "oop", "contents": "ostream &operator<<(ostream &out, const $1 &$2){\n\t${3:return out << $2;}\n}"},
        { "trigger": "floored_division", "contents": "template<class T>\nT floored_division(T x, T y){\n\treturn x / y - ((x ^ y) < 0 && x % y);\n}"},
        { "trigger": "cl", "contents": "cout << \"\\n\";"},
        { "trigger": "flush", "contents": "cout << endl;"},
        { "trigger": "changeto", "contents": "template<class T> T &ctmin(T &x){ return x; }\ntemplate<class T, class Head, class ...Tail> T &ctmin(T &x, const Head &h, const Tail &... t){ return ctmin(x = min<T>(x, h), t...); }\ntemplate<class T> T &ctmax(T &x){ return x; }\ntemplate<class T, class Head, class ...Tail> T &ctmax(T &x, const Head &h, const Tail &... t){ return ctmax(x = max<T>(x, h), t...); }\n"},
        { "trigger": "inrange", "contents": "auto in_range = [&](int ${1:x}, int ${2:y}){ return ${3:0 <= $1 && $1 < ${4:nr} && 0 <= $2 && $2 < ${5:nc}}; };"},
        { "trigger": "index", "contents": "auto index = [&](int ${1:x}, int ${2:y}){ return ${3:nc} * $1 + $2; };"},
        
        { "trigger": "fopen", "contents" : "ifstream cin; ofstream cout;\ncin.open(\"$1.in\"); cout.open(\"$1.out\");"},
        { "trigger": "fclose", "contents": "cin.close(); cout.close();"},
        { "trigger": "local", "contents": "#ifdef LOCAL\n$0\n#else\n\n#endif"},
        { "trigger": "mt19937", "contents": "mt19937(chrono::high_resolution_clock().now().time_since_epoch().count())"},
        { "trigger": "mt19937_64", "contents": "mt19937_64(chrono::high_resolution_clock().now().time_since_epoch().count())"},
        { "trigger": "yes", "contents": "cout << \"yes\\n\""},
        { "trigger": "Yes", "contents": "cout << \"Yes\\n\""},
        { "trigger": "YES", "contents": "cout << \"YES\\n\""},
        { "trigger": "no", "contents": "cout << \"no\\n\""},
        { "trigger": "No", "contents": "cout << \"No\\n\""},
        { "trigger": "NO", "contents": "cout << \"NO\\n\""},
        { "trigger": "json", "contents": "#include \"json.hpp\"\nusing json = nlohmann::json;"},
    ]
}